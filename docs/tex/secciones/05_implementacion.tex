\chapter{Implementación}

En este capítulo se describe el proceso de implementación junto con todos los elementos en los que éste se apoya, una descripción de todas las elecciones técnicas tomadas junto con su justificación.

En primer lugar se muestra el listado de las historias de usuario generadas junto con sus correspondientes tareas, que dan forma a las unidades de trabajo refinadas. Tras esto, se encuentran todos los dilemas tecnológicos considerados, junto con la solución seleccionada y  una lista de alternativas brevemente definidas con el fin de proveer una justificación fundada y válida de la elección tomada.

\subsection{Historias de usuario}

Partiendo de los requisitos previamente listados, refinándolos en historias de usuario, se puede dar paso a la elaboración de tareas que guíen la implementación del proyecto. Cabe aclarar que, como este desarrollo sigue una mentalidad ágil, las historias y tareas se han ido generando a corto plazo, por lo que la siguiente lista de historias de usuario y sus tareas se ha ido construyendo a lo largo del proceso de desarrollo.

Algunas historias, como ya se verá a continuación, aparecen repetidas. Esto se debe a que su desarrollo ha abarcado más de un PMV, pero en cada uno de estos se tratan diferentes tareas, por lo que solo se citaran las que correspondan al PMV descrito.

Así mismo cabe mencionar que el primer \textit{milestone} del proyecto se excluye de esta sección, pues está compuesto únicamente de documentación no directamente relacionada con las tareas de implementación.

\subsubsection{PMV-1. Estructura de datos básica y base de la lógica de negocio}

\begin{itemize}
    \item \href{https://github.com/Anglepi/My-Many-Reads/issues/7}{\textbf{HU-1}} Criterios de evaluación del jurado \\
    Como miembro del jurado, \\
    quiero recibir una documentación y presentación sobre este proyecto y su desarrollo, \\
    con el fin de poder evaluarlo en base a unos criterios específicos.
    \begin{itemize}
        \item \href{https://github.com/Anglepi/My-Many-Reads/issues/15}{\textbf{T-1.1}} Definir estructura básica de datos para los libros.
        \item \href{https://github.com/Anglepi/My-Many-Reads/issues/36}{\textbf{T-1.2}} Crear primera aproximación de BD de libros.
        \item \href{https://github.com/Anglepi/My-Many-Reads/issues/37}{\textbf{T-1.3}} Añadir requisitos para el segundo PMV.
    \end{itemize}
    \item \href{https://github.com/Anglepi/My-Many-Reads/issues/29}{\textbf{HU-2}} Solicitar información de libros \\
    Como Sergio, lector en MMR, \\
    quiero solicitar información sobre libros de una base de datos, \\
    con el fin de saber si me pueden interesar según sus características.
    \begin{itemize}
        \item \href{https://github.com/Anglepi/My-Many-Reads/issues/31}{\textbf{T-2.1}} Definir estructura básica de datos para los libros.
        \item \href{https://github.com/Anglepi/My-Many-Reads/issues/32}{\textbf{T-2.2}} Crear primera aproximación de BD de libros.
        \item \href{https://github.com/Anglepi/My-Many-Reads/issues/33}{\textbf{T-2.3}} Métodos para tratar las propiedades de los libros.
    \end{itemize}
    \item \href{https://github.com/Anglepi/My-Many-Reads/issues/30}{\textbf{HU-3}} Bibliotecas para gestionar lecturas
    Como Sergio, lector en MMR, \\
    quiero una biblioteca de libros de mi elección, \\
    con el fin de gestionar mis lecturas.
    \begin{itemize}
        \item \href{https://github.com/Anglepi/My-Many-Reads/issues/34}{\textbf{T-3.1}} Definir estructura básica de datos para las bibliotecas.
        \item \href{https://github.com/Anglepi/My-Many-Reads/issues/35}{\textbf{T-3.2}} Funcionalidad básica de gestión de bibliotecas.
    \end{itemize}
\end{itemize}

\subsection{Entorno de desarrollo}

A continuación se describen todos los elementos que conforman el entorno de desarrollo, justificando las elecciones tomadas enfrentándolas a las alternativas encontradas e indicando el por qué de la decisión en base a la naturaleza de este proyecto.

\subsubsection{Gestor de tareas}

\textbf{Elección final:} \href{https://www.gnu.org/software/make/}{\textit{make}}.

\textit{Make} es uno de los gestores de tareas más populares actualmente, muy probablemente debido a la sencillez de su uso e instalación y su versatilidad. El factor determinante para tomar esta decisión fue, principalmente, esta versatilidad, pues sabía que no solo lo usaría para gestionar actividades del desarrollo, sino para todo lo relacionado con la elaboración de este proyecto, incluida la documentación.

Esta elección fue de las primeras que hubo de tomarse, mucho antes de comenzar el desarrollo, pues como es lo habitual, el proyecto comenzó por una documentación e investigación que sirviera para justificar la viabilidad del mismo, sin ser muy relevantes los detalles técnicos del mismo.

Solo es necesario un fichero \textit{Makefile} en el que incluir las tareas a automatizar bajo sus nombres

Las alternativas a considerar se investigaron una vez se tomó la elección del lenguaje de programación a usar, ya que el resto de gestores de tareas genéricos con los que me he topado los descartaba, principalmente debido a la sintaxis que empleaban o a que requerían la instalación de complementos adicionales que, probablemente, no usaría para otra cosa, por lo que me pareció inconveniente.

\textbf{Alternativa principal:} \href{https://www.pyinvoke.org/}{\textit{invoke}}.

Es una muy buena herramienta para gestión de tareas en Python. Mediante un fichero \textit{tasks.py} se definen las tareas a realizar, y dado que la sintaxis de python es muy conocida y para nada compleja, no es difícil de construir. Además se pueden ejecutar órdenes en la línea de comandos muy fácilmente, por lo que también es muy versátil.

Muy probablemente habría sido la opción principal si se supiera desde el principio que se usaría Python para desarrollar el proyecto, dado que no tiene absolutamente nada que envidiarle a \textit{make}. Sin embargo éste se usaba desde el principio del proyecto, y dado que el cambio no aportaba ningún beneficio, se optó por descartar la opción.

\subsubsection{Editor de código}

\textbf{Elección final:} \href{https://code.visualstudio.com/}{\textit{Visual Studio Code}}.

Es el editor más potente y, desgraciadamente, eso se nota cuando se utiliza en máquinas de bajas prestaciones. Sin embargo, ofrece muchísimas opciones de configuración base, detecta una gran cantidad de lenguajes a los que provee de un formato visual de apoyo y es propiedad de \textit{Microsoft}, por lo que se espera un buen mantenimiento y actualizaciones frecuentes.

Destaca principalmente por ofrecer de forma nativa una terminal, que aunque por defecto usa la nativa del sistema en el que se encuentre instalado, es muy sencillo instalar y usar cualquier otra. Además existe una gama muy amplia de complementos gratuitos y desarrollados por la comunidad, muy fáciles de instalar y gestionar. 

El propio editor te ofrece sugerencias cuando detecta el entorno en el que estás trabajando, y ni si quiera es necesario recurrir al navegador web para consultar información de éstos o instalarlos, pues su gestor de complementos ya satisface todas estas necesidades. Algunos de estos complementos útiles para el proyecto son:
\begin{itemize}
    \item \href{https://marketplace.visualstudio.com/items?itemName=ms-python.python}{Python}, que ofrece características propias del lenguaje como \textit{linting}, \textit{debugging} y formateo de código.
    \item \href{https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens}{GitLens}, que aumenta las funcionalidades relacionadas con Git en el editor.
\end{itemize}

\textbf{Alternativa principal:} \href{https://www.sublimetext.com/}{\textit{Sublime Text}}.

Es otro editor muy popular, y aunque no tenga un equipo tan grande como el de \textit{Visual Studio Code} detrás, recibe actualizaciones de manera frecuente con notables mejoras.

Una ventaja que tiene frente al anterior es que no consume tantos recursos, pero dado que tengo la suerte de trabajar en una máquina de buenas prestaciones, este aspecto realmente no me supone un beneficio.

Por otra parte, lo que me hizo descartar esta opción fue el proceso de búsqueda e instalación de complementos, que es más manual y tediosa, así como la ausencia de una terminal en el entorno de forma nativa.

Cabe destacar que existen otras alternativas, IDEs para Python, que también pueden considerarse, como \href{https://docs.python.org/3/library/idle.html}{\textit{IDLE}}, que viene integrado, o \href{https://www.jetbrains.com/es-es/pycharm/}{\textit{PyCharm}} de JetBrains, un equipo muy conocido por desarrollar muy buenos IDEs.

Un IDE sería ideal si solo se fuera a trabajar en código, pero dado que este proyecto también requiere de documentación y podría incluir una variedad de tecnologías a emplear, un simple editor de código con complementos es mucho más adecuado.

\subsubsection{Lenguaje de programación}

\textbf{Elección final:} \textit{Python 3}.

\subsubsection{Herramientas ajenas a la programación.}

\textbf{Para escribir la documentación:} \textit{LaTeX} junto a \textit{markdown}.

\textbf{Revisión ortográfica:} \textit{aspell}