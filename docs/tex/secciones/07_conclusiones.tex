\chapter{Conclusiones, estado actual y futuro del proyecto}

En este último capítulo se recogerán las conclusiones obtenidas tras el desarrollo del proyecto hasta este punto, se resumirá el estado actual, con todas las características implementadas y se comentarán los pasos a seguir en etapas futuras de desarrollo.

\section{Conclusiones}

No existe una razón concreta por la que yo quise realizar un proyecto relacionado con libros, sino más bien mi intención fue la de poner a prueba mi capacidad para organizar un proyecto, así como emplear tecnologías que en mi trabajo no uso, con el fin de aprender un poco más y salir de mi zona de comfort.

Gracias a esto he aprendido bastante, y no solo con lo finalmente implementado en el proyecto sino con las numerosas alternativas que se consideraron y se pusieron a prueba en pequeños PoC (\textit{Proof of Concept}). Esto me ha permitido hacer una pequeña visita al estado de algunas tecnologías que se usan actualmente y me ha permitido contrastarlo con mi conocimiento previo, por lo que ahora me veo con una mejor capacidad de toma de decisiones al haber explorado más a fondo nuevas opciones.

También me ha permitido reafirmar algunas sospechas sobre ciertas formas de organizar el trabajo. Comencé pensando, erróneamente, que al ser un único desarrollador, el tamaño de las epopeyas y tareas refinadas debía más pequeño. Tras un primer intento de aplicar esta filosofía me di cuenta de que los costes en tiempo de la gestión administrativa de estas tareas empezaban a ser bastante altos en proporción al tiempo necesario para resolver dichas tareas, es decir, programar.

Por otra parte, los beneficios de esta gestión administrativa tienen menos impacto al tratarse de un trabajo en solitario. Al ser un único desarrollador, lo más común es tener el conocimiento y los objetivos de cada historia bastante claros, y parte de la intención de refinar y explicar apropiadamente cada una de las tareas a desarrollar es que otros desarrolladores puedan fácilmente trabajar en ellas sin tener que buscar información adicional del contexto de la tarea.

También me ha sorprendido la utilidad que tiene, a nivel de revisión, abrir \textit{pull requests} cuando solo hay un desarrollador. Aunque es cierto que mi tutor los revisaba, también me daba tiempo a ``aparcar'' la tarea un tiempo y desconectar, permitiéndome así revisar mi propio trabajo.

En cuanto a tecnologías, he aprendido bastante al estudiar y poner en práctica muchas de estas a las cuales no estoy acostumbrado. Un ejemplo de esto son los \textit{ORM}, de los cuales no conocía su existencia, y me parece una opción muy buena para determinados tipos de aplicaciones. Por otra parte, \textit{python} ha sido desde siempre un lenguaje que nunca me ha terminado de gustar como ya expliqué al momento de tomar esta decisión, pero al ver la cantidad de complementación que un \textit{linter} puede aportarle, como por ejemplo las anotaciones de tipo, ha hecho que mi opinión mejore, aunque sigue teniendo características que no me terminan de gustar como la complejidad de la gestión de los entornos de desarrollo.

En resumen, este proyecto me ha permitido aprender sobre diferentes tipos de bases de datos, la implementación de sistemas de integración continua, de los cuales solo me había servido de su utilidad anteriormente, y de la importancia de la configuración del entorno de desarrollo para acomodar el trabajo. Por otra parte, he podido experimentar el cierre del servicio de la base de datos que estaba usando, lo cual me ha permitido experimentar de primera mano que la migración es un proceso realmente simple, y que aunque estas situaciones resulten molestas, lidiar con ellas acaba siendo bastante sencillo.

\section{Estado actual}

Actualmente el proyecto se encuentra en fase de desarrollo puesto que quedan funcionalidades y partes por implementar que facilitarían en gran medida el uso de la plataforma, que no han sido incluidas por cuestiones prioritarias y se comentarán en la próxima sección.

En este punto \textit{My Many Reads} cuenta con casi toda la funcionalidad de \textit{backend} implementada, lo cual incluye las siguientes características principales: sistema de recomendaciones automático, recomendaciones de usuarios, gestión de bibliotecas y recogida y consulta de estadísticas. Toda esta funcionalidad se puede poner a disposición de los usuarios a través de un servidor web, y conectará con una base de datos externa para aportar persistencia entre ejecuciones.

Gracias a estas características, los usuarios pueden crear su propia biblioteca y puntuar sus lecturas, e incluso pueden crear diferentes bibliotecas según temáticas, enfoque de las lecturas o cualquier otro criterio. Adicionalmente, pueden participar activamente en el crecimiento de la plataforma creando recomendaciones entre libros, de forma que si un usuario ha leído dos libros que comparten alguna similitud, puede incluir una descripción de esta relación con el fin de ayudar al resto de usuarios.

El beneficio principal de dar uso a las funcionalidades anteriormente mencionadas es el de permitir que el sistema te ofrezca recomendaciones basadas en tus gustos y que además tengan en cuenta la información generada por otros usuarios. Este, junto con la capacidad de gestión de biblioteca, son los dos beneficios más importantes por los que se estima que los usuarios se verán atraídos a la plataforma.

Finalmente, gracias a la información que se genere por el uso de la plataforma, se crean unas estadísticas que resultan de utilidad para editoriales y vendedores, y esto será lo que permita a la plataforma obtener ingresos para mantenerse y, con suerte, generar beneficios.

\section{El futuro del proyecto}

Como todo proyecto software, su desarrollo y mantenimiento difícilmente acaba. En este caso, como ya se ha mencionado anteriormente, \textit{My Many Reads} aún carece de características que son necesarias para alcanzar el éxito.

\subsection{Búsqueda mejorada de libros}

Actualmente el sistema te permite consultar el conjunto de libros o un libro específico dado su identificador, y gracias a esto se pueden cumplir los objetivos mínimos de funcionalidad.

Sin embargo, lo mejor que se puede ofrecer para un sistema de búsqueda es la posibilidad de elegir un conjunto de criterios de búsqueda de relativa complejidad, que te permitan escoger géneros, autores, fechas de publicación y otros criterios para obtener los resultados.

Para afrontar este problema hay que tener en cuenta una serie de puntos importantes. En primer lugar hay que definir la estructura de la petición de este tipo de consultas. Lo más apropiado sería escuchar peticiones \textit{POST} con un cuerpo concreto, ya que si los criterios fueran a definirse en la propia ruta de la API, esta sería muy complicada de manejar.

El siguiente paso sería asegurarse de que el cuerpo de la petición \textit{POST} es el correcto. Validar y verificar correctamente todas las entradas de un usuario es uno de los puntos más importantes a tener en cuenta en cuanto a seguridad, ya que todo punto de entrada al sistema es susceptible de ser explotado. Para ello, cómo no, existen herramientas que facilitan la tarea, como \href{https://docs.pydantic.dev/latest/}{\textit{Pydantic}} que es la recomendada por \href{https://fastapi.tiangolo.com/tutorial/body/}{\textit{fastapi}}, o \href{https://python-jsonschema.readthedocs.io/en/stable/}{jsonschema}. 

Estas herramientas te permiten definir estructuras de datos para validar información respecto a estas de forma segura, y prácticamente todas ellas tienen muy buena flexibilidad para permitir especificar un conjunto de restricciones bastante amplio, por lo que la elección de esta herramienta dependerá no tanto de lo que ofrece, si no de su forma de uso.

Con esta información ya validada, habrá que construir los filtros en el lenguaje de consultas específico. Dado que actualmente se usan consultas escritas completamente por el desarrollador, esta parte requiere algo de estudio preliminar antes de elegir el enfoque a seguir. Dependiendo de la complejidad resultante permitida en estos filtros, quizás merezca la pena crear algún módulo de \textit{Domain Specific Language} que permita fácilmente traducir la información de los filtros deseados al lenguaje de consulta. Otra opción sería refactorizar y hacer uso de algún framework de creación de consultas o incluso reconsiderar la utilización de un ORM.

% Sesión de usuarios
% Página web, ¿aplicación?